"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _addEventListener = _interopRequireDefault(require("rc-util/lib/Dom/addEventListener"));

var _classnames = _interopRequireDefault(require("classnames"));

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _omit = _interopRequireDefault(require("omit.js"));

var _getScroll = _interopRequireDefault(require("../_util/getScroll"));

var _throttleByAnimationFrame = require("../_util/throttleByAnimationFrame");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2["default"])(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    left: 0,
    bottom: 0
  };
}

function getOffset(element, target) {
  var elemRect = element.getBoundingClientRect();
  var targetRect = getTargetRect(target);
  var scrollTop = (0, _getScroll["default"])(target, true);
  var scrollLeft = (0, _getScroll["default"])(target, false);
  var docElem = window.document.body;
  var clientTop = docElem.clientTop || 0;
  var clientLeft = docElem.clientLeft || 0;
  return {
    top: elemRect.top - targetRect.top + scrollTop - clientTop,
    left: elemRect.left - targetRect.left + scrollLeft - clientLeft,
    width: elemRect.width,
    height: elemRect.height
  };
}

function noop() {}

function getDefaultTarget() {
  return typeof window !== 'undefined' ? window : null;
}

var Affix =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2["default"])(Affix, _React$Component);

  function Affix() {
    var _this;

    (0, _classCallCheck2["default"])(this, Affix);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Affix).apply(this, arguments));
    _this.state = {
      affixStyle: undefined,
      placeholderStyle: undefined
    };
    _this.eventHandlers = {};
    _this.events = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];

    _this.saveFixedNode = function (node) {
      _this.fixedNode = node;
    };

    _this.savePlaceholderNode = function (node) {
      _this.placeholderNode = node;
    };

    return _this;
  }

  (0, _createClass2["default"])(Affix, [{
    key: "setAffixStyle",
    value: function setAffixStyle(e, affixStyle) {
      var _this2 = this;

      var _this$props = this.props,
          _this$props$onChange = _this$props.onChange,
          onChange = _this$props$onChange === void 0 ? noop : _this$props$onChange,
          _this$props$target = _this$props.target,
          target = _this$props$target === void 0 ? getDefaultTarget : _this$props$target;
      var originalAffixStyle = this.state.affixStyle;
      var isWindow = target() === window;

      if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {
        return;
      }

      if ((0, _shallowequal["default"])(affixStyle, originalAffixStyle)) {
        return;
      }

      this.setState({
        affixStyle: affixStyle
      }, function () {
        var affixed = !!_this2.state.affixStyle;

        if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {
          onChange(affixed);
        }
      });
    }
  }, {
    key: "setPlaceholderStyle",
    value: function setPlaceholderStyle(placeholderStyle) {
      var originalPlaceholderStyle = this.state.placeholderStyle;

      if ((0, _shallowequal["default"])(placeholderStyle, originalPlaceholderStyle)) {
        return;
      }

      this.setState({
        placeholderStyle: placeholderStyle
      });
    }
  }, {
    key: "syncPlaceholderStyle",
    value: function syncPlaceholderStyle(e) {
      var affixStyle = this.state.affixStyle;

      if (!affixStyle) {
        return;
      }

      this.placeholderNode.style.cssText = '';
      this.setAffixStyle(e, (0, _extends2["default"])({}, affixStyle, {
        width: this.placeholderNode.offsetWidth
      }));
      this.setPlaceholderStyle({
        width: this.placeholderNode.offsetWidth
      });
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(e) {
      var _this$props2 = this.props,
          offsetBottom = _this$props2.offsetBottom,
          offset = _this$props2.offset,
          _this$props2$target = _this$props2.target,
          target = _this$props2$target === void 0 ? getDefaultTarget : _this$props2$target;
      var offsetTop = this.props.offsetTop;
      var targetNode = target(); // Backwards support
      // Fix: if offsetTop === 0, it will get undefined,
      //   if offsetBottom is type of number, offsetMode will be { top: false, ... }

      offsetTop = typeof offsetTop === 'undefined' ? offset : offsetTop;
      var scrollTop = (0, _getScroll["default"])(targetNode, true);
      var affixNode = ReactDOM.findDOMNode(this);
      var elemOffset = getOffset(affixNode, targetNode);
      var elemSize = {
        width: this.fixedNode.offsetWidth,
        height: this.fixedNode.offsetHeight
      };
      var offsetMode = {
        top: false,
        bottom: false
      }; // Default to `offsetTop=0`.

      if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
        offsetMode.top = true;
        offsetTop = 0;
      } else {
        offsetMode.top = typeof offsetTop === 'number';
        offsetMode.bottom = typeof offsetBottom === 'number';
      }

      var targetRect = getTargetRect(targetNode);
      var targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;

      if (scrollTop > elemOffset.top - offsetTop && offsetMode.top) {
        // Fixed Top
        var width = elemOffset.width;
        var top = targetRect.top + offsetTop;
        this.setAffixStyle(e, {
          position: 'fixed',
          top: top,
          left: targetRect.left + elemOffset.left,
          width: width
        });
        this.setPlaceholderStyle({
          width: width,
          height: elemSize.height
        });
      } else if (scrollTop < elemOffset.top + elemSize.height + offsetBottom - targetInnerHeight && offsetMode.bottom) {
        // Fixed Bottom
        var targetBottomOffet = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;
        var _width = elemOffset.width;
        this.setAffixStyle(e, {
          position: 'fixed',
          bottom: targetBottomOffet + offsetBottom,
          left: targetRect.left + elemOffset.left,
          width: _width
        });
        this.setPlaceholderStyle({
          width: _width,
          height: elemOffset.height
        });
      } else {
        var affixStyle = this.state.affixStyle;

        if (e.type === 'resize' && affixStyle && affixStyle.position === 'fixed' && affixNode.offsetWidth) {
          this.setAffixStyle(e, (0, _extends2["default"])({}, affixStyle, {
            width: affixNode.offsetWidth
          }));
        } else {
          this.setAffixStyle(e, null);
        }

        this.setPlaceholderStyle(null);
      }

      if (e.type === 'resize') {
        this.syncPlaceholderStyle(e);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this3 = this;

      var target = this.props.target || getDefaultTarget; // Wait for parent component ref has its value

      this.timeout = setTimeout(function () {
        _this3.setTargetEventListeners(target); // Mock Event object.


        _this3.updatePosition({});
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.target !== nextProps.target) {
        this.clearEventListeners();
        this.setTargetEventListeners(nextProps.target); // Mock Event object.

        this.updatePosition({});
      }

      if (this.props.offsetTop !== nextProps.offsetTop || this.props.offsetBottom !== nextProps.offsetBottom) {
        this.updatePosition({});
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearEventListeners();
      clearTimeout(this.timeout);
      this.updatePosition.cancel();
    }
  }, {
    key: "setTargetEventListeners",
    value: function setTargetEventListeners(getTarget) {
      var _this4 = this;

      var target = getTarget();

      if (!target) {
        return;
      }

      this.clearEventListeners();
      this.events.forEach(function (eventName) {
        _this4.eventHandlers[eventName] = (0, _addEventListener["default"])(target, eventName, _this4.updatePosition);
      });
    }
  }, {
    key: "clearEventListeners",
    value: function clearEventListeners() {
      var _this5 = this;

      this.events.forEach(function (eventName) {
        var handler = _this5.eventHandlers[eventName];

        if (handler && handler.remove) {
          handler.remove();
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var className = (0, _classnames["default"])((0, _defineProperty2["default"])({}, this.props.prefixCls || 'ant-affix', this.state.affixStyle));
      var props = (0, _omit["default"])(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange']);
      var placeholderStyle = (0, _extends2["default"])({}, this.state.placeholderStyle, this.props.style);
      return React.createElement("div", (0, _extends2["default"])({}, props, {
        style: placeholderStyle,
        ref: this.savePlaceholderNode
      }), React.createElement("div", {
        className: className,
        ref: this.saveFixedNode,
        style: this.state.affixStyle
      }, this.props.children));
    }
  }]);
  return Affix;
}(React.Component);

exports["default"] = Affix;
Affix.propTypes = {
  offsetTop: PropTypes.number,
  offsetBottom: PropTypes.number,
  target: PropTypes.func
};

__decorate([(0, _throttleByAnimationFrame.throttleByAnimationFrameDecorator)()], Affix.prototype, "updatePosition", null);